## CPU调度与死锁

### 一、CPU调度的层次

> 高级调度

​	高级调度又称为作业调度，调度的对象是作业，主要功能是将外存上处于后备队列中的作业调入内存，为这些作业创建进程和分配必要的资源后放入就绪队列

> 中级调度

​	中级调度又称内存调度，内存调度把那些暂时不能运行的进程调至外存，使进程状态转变为挂起状态，主要功能是提高内存利用率和系统吞吐量

> 低级调度

​	低级调度又称进程调度，调度的对象是进程（或内核级线程），主要功能是依据某种策略使就绪队列中的进程进入执行状态

*执行频率：低级调度 > 中级调度 > 高级调度*  



> CPU调度算法的目标

* 资源利用率
* 公平性
* 平衡性
* 策略强制执行


#### 二、作业调度


> 作业调度

​	作业可看做是程序，作业从进入系统到运行结束，有三个阶段和三个状态

收容阶段：后备状态

运行阶段：运行状态

完成阶段：完成状态

> 作业调度算法

* 先来先服务调度算法（FCFS）
* 短作业优先调度算法（SJF）
* 优先级调度算法（PSA）
* 高响应比优先调度算法（HRRN)

#### 三、进程调度

> 进程调度

* 进程调度的任务
  * 保存CPU的现场信息：保存当前进程的上下文环境（程序计数器、寄存器值），当下次调度到该进程时可恢复进程的执行状态
  * 按某种算法选取进程：在进程就绪队列中选取一个进程，状态改为运行状态
  * 分配CPU给进程：把分配到CPU的进程的进程控制块的信息加载到CPU寄存器中

> 进程调度机制

​	在进程调度机制中，为实现进程调度应具有三个基本部分

* 排队器：就绪进程按某种算法组成的一个或多个对列，调度程序就能从中选取进程调度，即进程的就绪队列

* 分派器：负责从排队器中取出就绪进程，并保存进程的上下文环境

* 上下文切换器：1.将旧进程的上下文保存到该进程的进程控制块中，转入分派器中的上下文

  ​			   2.把新进程的上下文环境加载到CPU寄存器中

> 进程调度过程的理解

​	假设我们的操作系统有且仅有5个CPU，即只能同时运行5个进程，那我们可以用一场篮球比赛来类比进程调度机制。在NBA中，每场比赛一支队伍只能有5个球员在场上，其他球员则在替补席，可随时替补上场，则他们可以看作是就绪进程的一个队列，即排队器。在替补球员要上场前，需要先去裁判席登记，以便裁判知道是哪个球员要上场，即裁判席可看做是分派器。球员间的替换需要有一个记录表来记录换下和换上的球员的各项数据（犯规次数，得分），即保存进程的上下文环境信息。

> 进程调度的方式

* 非抢占式调度：就绪进程不会因为时钟中断或其他原因去抢占运行进程的CPU，只有等到运行进程运行结束或阻塞才能获取CPU
* 抢占式调度：抢占式调度运行调度程序按某种算法去暂停正在运行的进程，把CPU分配给另一个进程
  * 抢占原则
    * 优先权原则
    * 短进程优先原则
    * 时间片原则



> 进程调度算法

* 轮转调度算法（RR）

  在轮转调度算法中，系统根据先来先服务原则（FCFS)，将进程排成一个就绪进程队列，并设置一个时间片来产生中断，激活系统中的调度程序完成调度

* 优先级调度算法

  * 非抢占式优先级调度算法
  * 抢占式优先级调度算法

* 多队列调度算法：将系统中的进程按不同类型或性质分配在不同的就绪队列中，不同的就绪队列采用不同的调度算法

* 多机反馈队列调度算法

  * 设置多个就绪队列，每个队列有优先级
  * 每个队列采用先来先服务算法（FCFS）
  * 按队列优先级调度，只有当优先级最高的队列为空时，才调度优先级第二高队列中的进程

* 最早截止时间优先调度算法（EDF）

* 最低松弛度优先调度算法（LLF）：根据进程的紧急程度进行调度

#### 四、死锁

​	多个进程间都需要等待对方释放自己所需要的资源而循环等待阻塞

> 计算级的资源

​	导致死锁的原因可归纳为资源不足

* 可重用性资源：可重复使用多次的资源
* 可消耗性资源：由进程运行期间动态创建和销毁的资源，不可重用。
* 可抢占式资源：不会引起死锁
* 不可抢占性资源：会引起死锁

<u>死锁的原因通常是多个进程对资源的竞争，该资源可以是不可抢占式资源或可消耗性资源（进程AB等待彼此进程间产生的变量</u> 

> 死锁的定义	

​	如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程死锁

> 死锁产生的必要条件

* 互斥条件：进程所分配的资源具有排他性
* 请求并保持条件：进程请求的资源不能满足而阻塞，但对自己获得的资源部释放
* 不可抢占条件：进程已获得的资源不可被其他进程抢占，只能由自己释放
* 循环等待条件：各进程彼此等待其他进程的资源

> 处理死锁的方法

* 预防死锁：破坏请求并保持条件、破坏不可抢占条件、破坏循环等待条件
* 避免死锁：将系统状态分为安全状态和不安全状态。利用银行家算法
* 检测死锁：保存资源的请求和分配信息，依据信息来检测系统是否进入死锁状态
* 解除死锁：：利用检测死锁的算法判断系统是否进入死锁状态，若死锁则解除（破坏死锁的四个必要条件）