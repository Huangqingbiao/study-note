## Java内存区域与内存溢出异常

**一，概述**

​	对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为没一个new操作去编写配对的delete/free代码，不容易出现内存泄漏和内存溢出的问题，但一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误、修正问题将成为一项异常艰难的问题。



**二，Java虚拟机内存模型**

> 运行时数据区域

​	Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有些区域(方法区和堆)随着虚拟机进程的启动而一直存在，有些区域(程序计数器、虚拟机栈和本地方法栈)则是依赖用户线程的启动和结束而建立与销毁。



![运行时数据区](images/运行时数据区 .png)

* **程序计数器**

  ​	程序计数器(Program Counter Register)是一块较小的内存空间，它记录着当前线程所执行的*字节码* 的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线性之间计数器互不影响、独立存储。

  <u>各线程之间计数器互不影响、独立存储的内存区域称为“线程私有”的内存</u>

* **Java虚拟机栈**

  ​	与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stack)也是线程私有的，它的生命周期和线程相同。

  ​	Java虚拟机栈描述的是*Java方法执行*的线程内存模型：每个方法被执行时，Java虚拟机都会同步创建一个栈帧（方法运行时很重要的数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法被调用到执行结束的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

  ​	局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double)、对象引用和returnAddress类型（指向一条字节码指令的地址）。

  ​	局部变量表的存储空间一局部变量槽（slot)来表示，long和double类型占用两个变量槽，其余数据类型占用一个。局部变量表所需的内存空间在编译期间完成分配，每个方法需要在栈帧中分配的内存空间是完成确定的，在方法运行期间不会改变局部变量表的大小（“大小”指的是变量槽的数量）

* **本地方法栈**

  ​	本地方法栈（Native Method Stacks)与虚拟机栈所发挥的作用类似，区别只是虚拟机栈为虚拟机执行Java方法（即执行字节码）服务，而本地方法栈则为虚拟机使用到的本地方法服务。

  ​	<u>有的虚拟机（如HotSpot虚拟机）直接将本地方法栈和虚拟机栈合二为一。</u>

* **Java堆**

  ​	Java堆（Java Heap)是虚拟机所管理的*内存最大*的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，Java堆内存区域的唯一目的就是存放对象实例。

  ​	Java堆是垃圾收集器管理的内存区域，因此也被称为“GC堆”。

  ​	从内存分配的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB)，以提升对象分配时的效率，将Java堆细分的目的是为了更好的回收内存，或者更快的分配内存。但无论怎么划分，都不会改变Java堆中存储内容的共性，存储的内容都只能是对象的实例。

* **方法区 **

  ​	方法区（Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态常量、即时编译器编译后的代码缓存等数据.

  * 运行时常量池

    ​	运行时常量池（Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生产的各种字面量和***符号引用*** ，这部分内容将在类加载后存放到方法区的运行时常量池中。

    ​

  **三，HotSpot虚拟机对象探秘**

  	> 对象的创建

  ​	Java程序运行过程中无时无刻都有对象被创建出来，创建对象通常（复制、反序列化）仅仅是一个new操作，但在Java虚拟机中，对象的创建是怎样的过程呢？

  * 当Java虚拟机遇到一条new指令字节码时，首先将去检查这个指令的参数（类型）是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化，如果没有，则必须先执行相应的类加载过程。

  * 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存空间在类加载完成后是完全可以确定的。

    * Java堆中的内存如果是绝对规整的，则采用“指针碰撞”的分配方式。
    * Java堆中的内存如果不是规整的，则采用"空闲列表"的分配方式。

    Java堆是否规整由所采用的垃圾收集器是否带有**空间压缩整理**(Compact)的能力决定。

  * 内存分配完成后，虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值，以保证对象的实例字段在Java代码中可以不赋初始值就可以直接使用

  * Java虚拟机还要对对象进行必要的设置，例如对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头（Object Header）中。

    ​	<u>对象头的信息设置会根据虚拟机运行状态的不同而不同</u>

  * 准备调用构造函数，即class文件中的<init>()方法还没有执行，所有的字段值都为默认的零值，new指令之后会接着执行<init>()方法，按照构造函数的参数对对象进行初始化，这样一个对象才被真正构造出来。


  > 对象的内存布局

  ​	在HotSpot虚拟机中，对象的堆内存中存储布局可以划分为：对象头（Header）、实例数据（Instance Data)和对齐填充（Padding).

  * 对象头

    HotSpot虚拟机对象的对象头部分包括两类信息：

    * 第一类是用于存储对象自身运行时数据（哈希码、GC分代年龄、锁状态标志等信息），这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，称为“Mark Word”。
    * 第二类是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过该指针来确定该对象是那个类的实例，但查找对象的元数据信息并不一定要经过对象本身，如果对象是一个数组，那对象头中还必须有一块记录数组长度的数据。因为虚拟机可以通过对象的元数据信息确定Java对象的大小，但如果数组的长度是不确定的，将无法通过元数据信息推断数组的大小。

  * 实例数据

    实例数据部分的是对象真正存储的有效信息，即在代码中所定义的各种类型的字段内容，从父类继承和本类定义的字段都必须记录下来。这部分的存储顺序受虚拟机分配参数（-XX:FieldsAllocationStyle参数）和字段的定义顺序影响，父类定义的变量会出现的子类之前。

  * 对齐填充

    HotSpot虚拟机的自动内存管理系统要求对象起始地址必须的8字节的整数倍，也就是任何对象的大小都必须是8字节的整数倍，对象头已被精心设计为8字节的1倍或2倍，因此，如果实例数据部分不是8字节的整数倍的话，就要用对齐填充部分来补全。

  > 对象的访问定位

  ​	Java程序会通过栈上的reference数据来操作堆上的具体对象，对象的访问方式由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种。

  * 句柄

    使用句柄访问的话，Java堆中将可能会划分出一块来作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据和类型数据各自的具体地址信息。

    * 优势：reference中存储的是稳定的句柄地址，在对象被修改时只会改变句柄中实例数据的指针，而reference本身不需要修改。

  * 使用直接指针访问，Java堆中的对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中的存储的就是对象地址（包含对象类型数据地址的指针）

    * 优势：直接指针来访问最大的好处就是速度更快

