## 垃圾收集器与内存分配策略

### 一、概述

​	了解垃圾收集和内存分配能够在我们需要排查各种内存溢出、内存泄漏等问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”技术实施必要的监控和调节。

​	Java运行时区域中的程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，栈中的栈帧随着方法的进栈和出栈而有条不紊地执行，每一个栈帧中分配多少内存基本上式类结构确定的，这几个区域的内存分配和回收都具备确定性，当方法结束或线程结束时，内存自然就跟着回收了。

​	而Java堆和方法区的内存的分配和回收是动态的，垃圾收集器所关注的正是这部分内存该如何管理，即“内存”的分配和回收基本特指这两个区域。



### 二、对象已死？

​	判断对象是否存活的算法有：引用计数算法和可达性分析算法

> 引用计数算法

​	引用计数算法是指在对象中添加一个引用计数器，每当有一个地方引用该对象时，计数器值就+1，当引用失效时，计数器值-1，任何时刻计数器为零的对象就是不可能再被引用，即判定该对象“死”,应该被回收。

* 优点：原理简单，判断效率高

* 缺点：难以解决对象之间相互循环引用的问题

  ```java
  public class ReferenceCountingGC{
    public Object instance = null;
    public static void testGC(){
      ReferenceCountingGC objA = new ReferenceCountingGC();
      ReferenceCountingGC objB = new ReferenceCountingGC();
      objA.instance = objB;
      objB.instance = objA;
      
      objA = null;
      objB = null;
      
      system.gc();
    }
  }
  ```

  由程序代码可看出，objA和objB两个对象互相引用后又置为null，再进行垃圾回收。

  当在Java虚拟机中并没有回收这两个对象，说明了Java虚拟机并没有使用引用计数算法来回收垃圾。

> 可达性分析算法

​	可达性分析算法的基本思路是通过一系列的“GC Roots”的根对象作为起始节点集，从根对象根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”,如果某个对象没有到GC Roots的引用链，也就是说GC Roots到这个对象不可达时，则证明这个对象不再使用，应该被垃圾回收。



​	在Java技术体系中，固定可作为GC Roots的对象有：

* 在虚拟机栈（栈帧中的本地变量表）中引用的对象（参数、局部变量）
* 在方法区中类静态属性引用的对象（static）
* 在方法区中常量引用的对象（字符串常量）
* 在本地方法栈中JNI（Java本地接口，通常说的本地（Native）方法）引用的对象
* Java虚拟机内部的引用（系统类加载器，基本数据类型的Class对象，异常对象（NullPointException、OutOfMemoryError））
* 所有被同步锁持有的对象（synchronized关键字）
* 反映Java虚拟机内部情况的JMXBean、JVMT中注册的回调、本地代码缓存等



> 引用reference

​	Java里面的引用是很传统的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据时代表某块内存、某个对象的引用

​	JDK1.2后，Java对引用的概念进行的扩充，进引用分为*强引用(Strongly Reference)* 、*软引用(Soft Reference)* 、*弱引用(Weak Reference)* 、*虚引用(Phantom Reference)* ,这4种引用的强度依次逐渐减弱。

> 回收方法区	

​	方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型

​	判断一个类型是否“废弃”需要同时满足3个条件：

* 该类所有实例多已经被回收
* 加载该类的类加载器已经被回收
* 该类对应的Class对象没有再任何地方被引用，无法在任何地方通过反射访问该类的方法



### 垃圾收集算法

* 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾，分有：
  * 新生代收集（Minor GC）：指目标只收集新生代的垃圾
  * 老年代收集（Major GC）：指目标只收集老年代的垃圾
  * 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾
* 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾

​	垃圾收集算法可划分为“引用计数式垃圾收集“（Reference Counting GC）和”追踪式垃圾收集”（Tracing GC），这两类也被称为“直接垃圾收集”和“间接垃圾收集”

> 分代收集理论

* 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的

* 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难消亡

  垃圾收集器一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据存活时长分配到不同的区域中存储。

  将Java堆划分出不同的去也后，垃圾收集器才可以每次只回收其中一个或者某些部分的区域——因而有了“Minor GC”、“Major GC" 、”Full GC“的回收类型的划分，以匹配针对不同区域里存储的对象存亡特征的垃圾收集算法 *标记—清除算法* 、 *标记—复制算法* 、 *标记—整理算法* 

  Java堆一般划分为新生代（Young Generation）和老年代（Old Generation）两个区域

  将Java堆分区带来的问题是：Java对象并不是孤立的，对象之间会存在跨代引用

* 跨代引用假说：跨代引用相对于同代引用来说只是占极少数

> 标记—清除算法

​	标记—清除算法分两个阶段：“标记”和“清除”

​	首先标记出所有需要回收的对象，标记完成后，统一回收掉所有被标记的对象，或者标记存活的对象，清除未标记的对象。

> 标记—复制算法

​	标记—复制算法是一种被称为“半区复制”的垃圾收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当其中一块的内存用完了，就将还存活的对象复制到另外的一块内存上面

​	由于新生代中的对象有98%的对象都熬不过第一轮收集，因此并不需要按照1:1的比例来划分新生代的内存空间，所以出现了一种优化的半区复制算法”Appel式回收“，把新生代的内存空间分为一块较大的Eden空间和两块较小的Survivor空间。

> 标记—整理算法

​	标记—整理算法是针对老年代对象的存亡特征，在标记对象后不是直接对可回收对象进行整理，而是让所有存活对象都向内存空间一端移动，然后直接清理掉边界意外的内存



### HotSpot的算法细节实现

> 根节点枚举	

​	在HotSpot中GC Boots的枚举的解决方案里，使用一组称为OopMap的数据结构来完成，一旦类加载动作完成时，HotSpot就会把对象内的什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器那些位置是引用

[^即时编译]: 某段代码即将第一次执行是进行编译     

> 安全点

​	那些记录了对对象的引用的地方（即存放了OopMap数据结构的地方）的位置被称为安全点

​	一般只有在如方法调用、循环跳转、异常跳转等指令序列复用的代码中才会产生安全点

​	如何在垃圾收集发生时让所有线程都跑到最近的安全点，然后停顿下来：

>抢占式中断

​	垃圾收集发生时，系统首先会把所有用户线程都中断

> 主动式中断

​	主动式中断的思想是当垃圾收集需要中断用户线程时，不直接对线程操作，而是设置一份标志，各个线程在执行过程中不断地轮询这个标志，一旦发现中断标志为true时就自己在最近的安全点上主动中断挂起，轮询标志的地方和安全点是重合的



> 安全区域

​	安全点针对的是程序运行时的场景，当程序没有执行时就必须引入安全区域来进行垃圾收集

​	安全区域是指能够确保在某一段代码片段中，引用关系不会发生变化，因此，在这个区域中的任意地方开始垃圾收集都是安全的

> 记忆集和卡表

​	垃圾收集器在新生代中建立了记忆集的数据结构，用以避免把整个老年代加入GC Boots的扫描范围

​	记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结

​	记忆集的记录精度：

* 字长精度：机器字长（取决于计算机的地址总线），包含跨代指针

* 对象精度：每个记录精确到一个对象，包含跨代指针

* 卡精度：每个记录精确到一块内存区域，包含跨代指针

  “卡精度”所指的是用一种称为“卡表”的方式去实现记忆集

  卡表最简单的形式可以是一个字节数组，卡表中的每个元素对应着其标识的内存区域中的一块特定大小的内存块（卡页），HotSpot的卡页为512bit

> 写屏障

​	

